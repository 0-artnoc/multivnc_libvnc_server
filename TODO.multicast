- check if this vncrec stuff is still working.

- implement server throttling

- verify sender address in  ReadFromRFBServerMulticast(). 
  -> use connect()!

- sendCursorShape, sendCursorPos, sendKeyboardLedState, 
  rfbSendCopyRegion must be sent even if unicast update 
  region is empty! --> put these in rfbSendMulticastFBupdate()?

- what about the enableCursorShapeUpdates stuff in 
  rfbSendMulticastFramebufferUpdate()?

- Implement other encodings than raw.

- make the lossratio levels in rfbProcessServerMessage()
  configurable like maxMulticastTimeouts? Shall we then provide
  pluggable actions for each of these via function pointers. OTOH,
  users still have every freedom if they just don't use 
  rfbProcessServerMessage() and implement their own one...

- What about multicast specific stats? Right now it's still all
  per-client.

- client side: introduce a new multicast function for each unicast one
  or use a solution with an internal flag that signals that a function
  should behave the multicast way instead? actually, this also hold
  true for the server side... hmm.

- Leave the nRect calculation in rfbSendMulticastFramebufferUpdate()
  as it is (number of rects is returned by
  rfbPutMulticastEndcodingPreferred)?
  --> We're not able to catch some obscure errors in the encoding
      specific functions. but what errors? It's guaranteed beforehand
      that the rects always fit, so that leaves us with some deflate
      errors and stuff. do these ever happen?
  --> Other possibility would be to have sth like a
      rfbGetNrRectsPreferredEncoding() which would be used by
      rfbSendMulticastFramebufferUpdate() and
      rfbSendFramebufferUpdate(). Then we would need to turn of
      cl->lastrectenabled in the multicast case and re-enable it later
      on



  



